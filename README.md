# Holosphere: A Spherical POV Display Engine

## Overview

**Holosphere** is a graphics engine designed for Teensy-based Persistence of Vision (POV) displays. The engine abstracts the spinning hardware into a **virtual 3D unit sphere**.

It implements a pipeline for rendering 3D vectors, particle systems, and geometries onto a spherical surface. The engine handles the trigonometry required to map Cartesian 3D coordinates to the polar coordinates of the LED strip.

### Key Features

  * **3D-to-Spherical Projection**: Handles 3D vectors and projects them to physical LED addresses.
  * **Temporal Motion Blur**: The `Orientation` system tracks object history within a single frame to draw continuous arcs.
  * **Filter Chain**: A modular pipeline for post-processing effects such as trails and anti-aliasing.
  * **Animation Timeline**: A system for scheduling sequences using tweens, sprites, and timers.

-----

## Engine File Structure & Responsibilities

The engine is modularized into several headers, each handling a specific layer of the rendering pipeline, from low-level math to high-level hardware control.

### 1\. Core Mathematics (`3dmath.h`)

This file provides the fundamental mathematical primitives used throughout the engine. It relies on floating-point math (`float`) for performance on the Teensy 4.x FPU.

  * **`Vector`**: A struct representing a 3D point or direction $(x, y, z)$ in Cartesian space. It includes operator overloads for vector addition, subtraction, scalar multiplication, and normalization.
  * **`Quaternion`**: Implements rotation math. Used to represent the orientation of objects and the camera without suffering from Gimbal lock.
  * **`Spherical`**: A helper struct for Polar coordinates ($\theta, \phi$), used during the final projection step.
  * **Helper Functions**: Includes `dot` product, `cross` product, `slerp` (Spherical Linear Interpolation) for smooth rotation blending, and `intersection` logic for geometry calculations.

### 2\. 3D Scene Graph (`geometry.h`)

This file defines how mathematical objects are represented in the Holosphere's virtual world.

  * **`Orientation`**: The engine's solution for high-speed motion blur. Instead of a single rotation state, it maintains a history of `Quaternion` states for the current frame. The `tween()` function uses this history to draw objects as continuous arcs rather than static points.
  * **`Dot`**: The atomic unit of rendering. A `Dot` consists of a `Vector` (position) and a `Pixel` (color).
  * **Projection**: Contains `vector_to_pixel<W>()`, which converts normalized 3D vectors into 2D virtual coordinates $(x, y)$ mapped to the LED strip's resolution.
  * **`Dodecahedron`**: Example mesh data containing vertices and edge lists for a 3D solid.

### 3\. Hardware Abstraction (`led.h`)

This file bridges the software engine with the physical reality of the spinning device.

  * **`POVDisplay`**: Manages the hardware resources. It sets up the LED controller (FastLED) and initializes the hardware interval timer based on the desired `RPM` and resolution.
  * **`Effect`**: The base class for all visual sketches. It implements **Double Buffering**: one buffer is written to by the drawing code while the other is read by the interrupt service routine (ISR) to light the LEDs.
  * **`Canvas`**: A RAII (Resource Acquisition Is Initialization) wrapper around the frame buffer. Creating a `Canvas` object automatically locks the buffer for writing; destroying it queues the frame for display.

### 4\. Rasterization Pipeline (`filter.h`)

Instead of drawing directly to the screen, the engine "plots" generic 3D dots through a chain of filters. This allows separation of concerns between *where* something is and *how* it looks.

  * **`Filter`**: The abstract base class. Each filter holds a pointer to the `next` filter in the chain.
  * **`FilterOrient`**: Intercepts a dot, applies the global camera `Orientation` (rotating the world), and passes the new position down the chain.
  * **`FilterDecay`**: Manages persistence. It stores a history of plotted pixels and their "time to live" (TTL). In subsequent frames, it re-plots these pixels with reduced brightness to create trails.
  * **`FilterAntiAlias`**: Performs the final rasterization. It takes the floating-point 2D coordinates from the projection step and distributes the pixel's energy to the four nearest integer coordinates on the physical LED strip.

### 5\. Geometry Generation (`draw.h`)

A collection of helper functions to generate 3D forms and push them into the `Dots` buffer.

  * **`Path`**: A class representing a trajectory in 3D space. It can be defined procedurally or by connecting vectors.
  * **Primitives**: `draw_line` (draws a great-circle arc between two vectors), `draw_ring` (draws a circle on the sphere surface), and `draw_polyhedron` (draws a wireframe mesh).
  * **`Dots`**: A `StaticCircularBuffer` used as intermediate storage for the points generated by these functions before they are processed by the Filter chain.

### 6\. Animation System (`animation.h`)

Provides a scripting framework to make visuals move and evolve over time without messy state variables in the main loop.

  * **`Timeline`**: The master clock. It stores and advances a list of active `Animation` objects.
  * **`Transition`**: Smoothly interpolates a value (like a color or angle) from $A$ to $B$ over a set duration.
  * **`Motion` / `Rotation`**: Specialized animations that update an `Orientation` object, moving it along a `Path` or spinning it around an axis.
  * **`Sprite`**: Manages the lifecycle of a drawing function, handling fade-in, active duration, and fade-out automatically.
  * **Easing Functions**: Standard easing curves (`ease_in_out_sin`, `ease_out_expo`) used by animations for natural motion.

### 7\. Color System (`color.h`)

Tools for managing color theory and high-quality rendering.

  * **`GenerativePalette`**: A class that procedurally generates harmonious color palettes (e.g., Triadic, Analogous) based on random seeds and rules.
  * **`ProceduralPalette`**: Defines gradients using cosine waves for smooth, mathematically defined color shifts.
  * **Gamma Correction**: A lookup table (`gamma_lut`) used to convert linear calculated colors into values that appear correct to the human eye on LEDs.

### 8\. Utilities (`static_circular_buffer.h` & `FastNoiseLite.h`)

  * **`StaticCircularBuffer`**: A custom container that provides a fixed-size circular buffer (deque) without using dynamic memory allocation (`new`/`malloc`), critical for system stability on microcontrollers.
  * **`FastNoiseLite.h`**: A third-party library used to generate Perlin/Simplex noise for organic textures and random walks.

-----

## Usage Example: Composing a "Satellite" Effect

The following code demonstrates creating a "Satellite" effect: a dot orbiting the equator while the world view rotates.

```cpp
template <int W>
class SatelliteEffect : public Effect {
public:
  SatelliteEffect() : Effect(W), trails(20), orient(world_view) {
    // 1. PIPELINE SETUP
    // Order: Decay -> Orient -> AA -> Screen
    trails.chain(orient).chain(aa); 

    // 2. ANIMATION SETUP
    // Spin the satellite's local coordinate system
    timeline.add(0, Rotation<W>(satellite_view, Y_AXIS, 0.1, -1, ease_mid));
    
    // Rotate the global world view
    timeline.add(0, Rotation<W>(world_view, Z_AXIS, 0.01, -1, ease_mid));
  }

  // Return false to maintain previous frame buffer (for trails)
  bool show_bg() const override { return false; } 

  void draw_frame() override {
    Canvas canvas(*this);
    timeline.step(canvas); 
    
    // 3. DRAWING
    // Iterate through the rotation history for this frame
    tween(satellite_view, [&](auto orient_fn, auto t) {
        dots.clear();
        
        // Define a vector at (1,0,0)
        Vector p = Vector(1, 0, 0);
        
        // Apply the satellite's rotation
        p = orient_fn(p);
        
        // Add to buffer
        draw_vector<W>(dots, p, [](auto v, auto t) { return CRGB::Red; });
        
        // 4. PLOTTING
        // Push dots through the filter chain
        plot_dots<W>(dots, trails, canvas, t, 1.0);
    });
    
    // 5. CLEANUP
    trails.decay(); 
    // Re-draw existing trails with calculated dimming
    trails.trail(canvas, [](float x, float y, float t) { 
        return CRGB::Red.nscale8(255 * (1.0 - t)); 
    }, 1.0);
  }

private:
  Timeline timeline;
  Orientation satellite_view; 
  Orientation world_view;     
  Dots dots;                  
  
  FilterDecay<W, 1024> trails; 
  FilterOrient<W> orient;      
  FilterAntiAlias<W> aa;       
};
```

## Requirements

1.  **Hardware**: Teensy 4.0/4.1 (Required for FPU and clock speed).
2.  **Dependencies**: **FastLED** library.
3.  **Configuration**: Update `led.h`:
      * `NUM_PIXELS`: Total LED count.
      * `RPM`: Motor rotation speed.
