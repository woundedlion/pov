#pragma once
/**
 * @brief Draws a single vector (point) on the unit sphere.
 * @tparam W The width of the display (used for projection context).
 * @param dots The buffer to which the Dot will be added.
 * @param v The 3D vector position (will be normalized).
 * @param color_fn The color function to determine the pixel's color.
 */
template <int W>
void draw_vector(Dots& dots, const Vector& v, ColorFn color_fn) {
  Vector u(v);
  u.normalize();
  dots.emplace_back(Dot(u, color_fn(u, 0)));
}

/**
 * @brief Draws a great-circle arc (line) between two 3D vectors on the unit sphere.
 * @tparam W The width of the display (used for step calculation).
 * @param dots The buffer to which the resulting Dots will be added.
 * @param v1 The starting vector.
 * @param v2 The ending vector.
 * @param color The color function for the line segment.
 * @param long_way If true, draws the longer arc around the sphere.
 * @param start The normalized start position of the line (0.0 to 1.0).
 * @param end The normalized end position of the line (0.0 to 1.0).
 */
template <int W>
void draw_line(Dots& dots, const Vector& v1, const Vector& v2, ColorFn color,
  float start = 0, float end = 1, bool long_way = false)
{
  Vector u(v1);
  Vector v(v2);
  u.normalize();
  v.normalize();

  float a = angle_between(u, v);
  if (std::abs(a) < TOLERANCE) {
    dots.emplace_back(Dot(u, color(u, 1.0f)));
    return;
  }
  Vector w;
  if (std::abs(PI_F - a) < TOLERANCE) {
    if (std::abs(dot(v, X_AXIS)) > 1 - TOLERANCE) {
      w = cross(u, Y_AXIS).normalize();
    } else {
      w = cross(u, X_AXIS).normalize();
    }
  } else {
    w = cross(u, v).normalize();
  }

  if (long_way) {
    a = 2 * PI_F - a;
    w = -w;
  }

  // Trim start and end
  if (std::abs(start) > TOLERANCE) {
    Quaternion q = make_rotation(w, start * a);
    u = rotate(u, q).normalize();
  }
  a *= std::abs(end - start);

  int num_steps = std::max(1, static_cast<int>(std::ceil((a / (2 * PI_F)) * W)));
  Quaternion q = make_rotation(w, a / num_steps);
  for (int i = 0; i <= num_steps; ++i) {
    dots.emplace_back(Dot(u, color(u, static_cast<float>(i) / num_steps)));
    u = rotate(u, q).normalize();
  }
}

/**
 * @brief Represents a customizable path or trajectory in 3D space.
 * @tparam W The width of the display (used for samples/resolution).
 */
template <int W>
class Path {
public:
  Path() {}

  /**
   * @brief Appends a great-circle arc segment to the path.
   * @param v1 The starting vector.
   * @param v2 The ending vector.
   * @param long_way If true, takes the longer path.
   * @return Reference to the Path object.
   */
  Path& append_line(const Vector& v1, const Vector& v2, bool long_way = false) {
    if (points.size() > 0) {
      points.pop_back(); // Overlap previous segment
    }
    Dots seg;
    draw_line<W>(seg, v1, v2, [](auto&, auto) { return Pixel(); }, 0.0f, 1.0f, long_way);
    std::transform(seg.begin(), seg.end(), std::back_inserter(points),
      [](auto& d) { return d.position; });
    return *this;
  }

  /**
   * @brief Appends a segment generated by a plotting function.
   * @param plot A function that generates a Vector given a float input (time/domain).
   * @param domain The maximum input value for the plot function.
   * @param samples The number of points to sample along the segment.
   * @param easing The easing function to apply to the time factor.
   * @return Reference to the Path object.
   */
  Path& append_segment(PlotFn plot, float domain, float samples, EasingFn easing) {
    if (points.size() > 0) {
      points.pop_back(); // Overlap previous segment
    }
    for (float t = 0; t <= samples; t++) {
      points.push_back(plot(easing(t / samples) * domain));
    }
    return *this;
  }

  /**
   * @brief Retrieves a point along the path based on a normalized factor.
   * @param t The normalized factor (0.0 to 1.0).
   * @return The Vector at that point.
   */
  Vector get_point(float t) const {
    return points[static_cast<int>(t * (points.size() - 1))];
  }

  /**
   * @brief Gets the total number of discrete points in the path.
   * @return The number of points.
   */
  size_t num_points() const { return points.size(); }

  /**
   * @brief Reduces the path to a single point: the last recorded position.
   */
  void collapse() {
    if (points.size() > 1) {
      points = { points.back() };
    }
  }

private:

  StaticCircularBuffer<Vector, 1024> points; /**< The discrete points making up the path. */
};

/**
 * @brief Draws a Path object by sampling its points and adding them as dots.
 * @tparam W The width of the display.
 * @param dots The buffer to which the resulting Dots will be added.
 * @param path The Path object to draw.
 * @param color The color function.
 */
template <int W>
void draw_path(Dots& dots, const Path<W>& path, ColorFn color) {
  size_t samples = path.num_points();
  for (size_t i = 0; i < samples; ++i) {
    auto v = path.get_point(static_cast<float>(i) / samples);
    dots.push_back(Dot(v, color(v, i / (samples - 1))));
  }
}

/**
 * @brief Draws a set of vertices (points) without connecting them.
 * @param dots The buffer to which the resulting Dots will be added.
 * @param vertices The list of vertex vectors.
 * @param color_fn The color function.
 */
void draw_vertices(Dots& dots, const VertexList& vertices, ColorFn color_fn) {
  for (Vector v : vertices) {
    dots.emplace_back(Dot(v.normalize(), color_fn(v, 0)));
  }
}

/**
 * @brief Draws the wireframe of a polyhedron by connecting vertices based on adjacency.
 * @tparam W The width of the display.
 * @param dots The buffer to which the resulting Dots will be added.
 * @param vertices The list of vertex vectors.
 * @param edges The adjacency list defining which vertices are connected.
 * @param color_fn The color function.
 */
template <int W>
void draw_polyhedron(Dots& dots, const VertexList& vertices, const AdjacencyList& edges, ColorFn color_fn) {
  for (size_t i = 0; i < edges.size(); ++i) {
    Vector a(vertices[i]);
    for (auto j : edges[i]) {
      Vector b(vertices[j]);
      draw_line<W>(dots, a, b, color_fn);
    }
  }
}

/**
 * @brief Calculates a 3D point on a circle that may be offset from the sphere's origin.
 * @param a The angle along the ring.
 * @param radius The radius of the ring relative to the sphere.
 * @param u Unit vector in the ring's local horizontal direction.
 * @param v Unit vector along the ring's normal.
 * @param w Unit vector in the ring's local vertical direction.
 * @return The calculated point, normalized to the unit sphere.
 */
Vector calc_ring_point(float a, float radius, const Vector& u, const Vector& v, const Vector& w) {
  auto d = sqrtf((1 - radius) * (1 - radius));
  return Vector(
    d * v.i + radius * u.i * cosf(a) + radius * w.i * sinf(a),
    d * v.j + radius * u.j * cosf(a) + radius * w.j * sinf(a),
    d * v.k + radius * u.k * cosf(a) + radius * w.k * sinf(a)
  ).normalize();
}

/**
 * @brief Calculates a single point on a ring that is also perturbed by a function (shiftFn).
 * @param f The function defining the radial shift (ShiftFn).
 * @param normal The normal vector defining the plane of the ring.
 * @param radius The radius of the ring.
 * @param angle The angle along the ring.
 * @return The calculated and rotated 3D point (unit vector).
 */
Vector fn_point(ShiftFn f, const Vector& normal, float radius, float angle) {
  Vector v(normal);
  if (radius > 1) {
    v = -v;
  }
  Vector u;
  if (std::abs(dot(v, X_AXIS)) > (1 - TOLERANCE)) {
    u = cross(v, Y_AXIS);
  }
  else {
    u = cross(v, X_AXIS);
  }
  u.normalize();
  Vector w(cross(v, u));
  if (radius > 1) {
    w = -w;
    radius = 2 - radius;
  }

  auto vi = calc_ring_point(angle, radius, u, v, w);
  auto vp = calc_ring_point(angle, 1, u, v, w);
  Vector axis = cross(v, vp).normalize();
  auto shift = make_rotation(axis, f(angle * PI_F / 2));
  return rotate(vi, shift);
};

/**
 * @brief Draws a ring defined by a normal vector and applies a functional shift (drawFn).
 * @tparam W The width of the display.
 * @param dots The buffer for the resulting Dots.
 * @param orientationQuaternion The current rotational state of the normal.
 * @param normal The normal vector defining the plane of the ring.
 * @param radius The radius of the ring.
 * @param shift_fn The function defining the radial shift (ShiftFn).
 * @param color_fn The color function (ColorFn).
 * @param phase The angular offset.
 */
template <int W>
void draw_fn(Dots& dots, const Quaternion& orientationQuaternion, const Vector& normal,
  float radius, ShiftFn shift_fn, ColorFn color_fn, float phase = 0)
{
  // Basis
  Vector ref_axis = X_AXIS;
  if (std::abs(dot(normal, ref_axis)) > 1- TOLERANCE) {
    ref_axis = Y_AXIS;
  }
  Vector v = rotate(normal, orientationQuaternion).normalize();
  Vector ref = rotate(ref_axis, orientationQuaternion).normalize();
  Vector u = cross(v, ref).normalize();
  Vector w = cross(v, u).normalize();

  // Backside rings
  float v_sign = 1.0f;
  if (radius > 1.0f) {
    v_sign = -1.0f;
    radius = 2.0f - radius;
  }

  // Equidistant projection
  const float theta_eq = radius * (PI_F / 2.0f);
  const float r = sinf(theta_eq);
  const float d = cosf(theta_eq);
  int num_steps = W;
  Vector start, from, to;
  for (int i = 0; i < num_steps; ++i) {
    float t = static_cast<float>(i) / num_steps;

    // Ring step
    float theta = t * 2.0f * PI_F + phase;
    float cos_ring = cosf(theta);
    float sin_ring = sinf(theta);
    Vector u_current = u * cos_ring + w * sin_ring;

    // Rodrigues Rotation for shift
    float shift = shift_fn(t);
    float cos_shift = cosf(shift);
    float sin_shift = sinf(shift);
    float v_scale = (v_sign * d) * cos_shift - r * sin_shift;
    float u_scale = r * cos_shift + (v_sign * d) * sin_shift;
    to = ((v * v_scale) + (u_current * u_scale)).normalize();

    if (i == 0) {
      start = to;
    } else {
      draw_line<W>(dots, from, to, [&color_fn, &from, i, num_steps](const Vector&, float) {
          return color_fn(from, static_cast<float>(i - 1) / num_steps);
        });
      dots.pop_back();
    }
    from = to;
  }

  // Close the loop
  draw_line<W>(dots, from, start,
    [&from, &color_fn](const Vector&, float) {
      return color_fn(from, 1.0f);
    });
  dots.pop_back();
};

/**
 * @brief Calculates a single point on a ring based on angle and phase.
 * @param normal The normal vector defining the plane of the ring.
 * @param radius The radius of the ring.
 * @param angle The angle along the ring.
 * @param phase The angular offset.
 * @return The calculated 3D point (unit vector).
 */
Vector ring_point(const Vector& normal, float radius, float angle, float phase = 0) {
  Vector v(normal);
  if (radius > 1) {
    v = -v;
  }
  Vector u;
  if (std::abs(dot(v, X_AXIS)) > (1 - TOLERANCE)) {
    u = cross(v, Y_AXIS);
  }
  else {
    u = cross(v, X_AXIS);
  }
  u.normalize();
  Vector w(cross(v, u));
  if (radius > 1) {
    w = -w;
    radius = 2 - radius;
  }
  return calc_ring_point(angle + phase, radius, u, v, w);
};

/**
 * @brief Draws a complete ring (circle) on the unit sphere, oriented by the scene's rotation.
 * @tparam W The width of the display (used for step calculation).
 * @param dots The buffer for the resulting Dots.
 * @param orientationQuaternion The orientation of the normal
 * @param normal The normal vector defining the plane of the ring (unoriented).
 * @param radius The radius of the ring.
 * @param color_fn The color function (ColorFn).
 * @param phase The angular offset.
 */
template<int W>
void draw_ring(Dots& dots, const Quaternion& orientationQuaternion, const Vector& normal,
  float radius, ColorFn color_fn, float phase = 0)
{
  // Basis
  Vector ref_axis = X_AXIS;
  if (std::abs(dot(normal, ref_axis)) > 1 - TOLERANCE) {
    ref_axis = Y_AXIS;
  }
  Vector v = rotate(normal, orientationQuaternion).normalize();
  Vector ref = rotate(ref_axis, orientationQuaternion).normalize();
  Vector u = cross(v, ref).normalize();
  Vector w = cross(v, u).normalize();

  // Backside rings
  Vector v_dir = v;
  if (radius > 1.0f) {
    v_dir = -v_dir;
    radius = 2.0f - radius;
  }

  // Equidistant projection
  const float theta_eq = radius * (PI_F / 2.0f);
  const float r = sinf(theta_eq);
  const float d = cosf(theta_eq);
  int num_steps = W;

  for (int i = 0; i < num_steps; ++i) {
    float t = static_cast<float>(i) / num_steps;
    float theta = t * 2.0f * PI_F + phase;
    float cos_ring = cosf(theta);
    float sin_ring = sinf(theta);
    Vector u_current = u * cos_ring + w * sin_ring;
    Vector to = ((v_dir * d) + (u_current * r)).normalize();
    dots.emplace_back(Dot(to, color_fn(to, t)));
  }
}

/**
 * @brief Applies a discrete square wave mask to a color, simulating a dotted or striped brush.
 * @param color The base pixel color.
 * @param freq The frequency of the square wave.
 * @param duty_cycle The duty cycle (proportion of 'on' time).
 * @param phase The phase shift.
 * @param t The position/time factor (0.0 to 1.0).
 * @return The dimmed (or full brightness) pixel color.
 */
Pixel dotted_brush(const Pixel& color, float freq, float duty_cycle, float phase, float t) {
  return dim(color, square_wave(0, 1, freq, duty_cycle, phase)(t));
}

/**
 * @brief Plots a buffer of Dots to the Canvas, routing the data through the filter chain.
 * @tparam W The width of the display.
 * @param dots The buffer of Dots to plot.
 * @param filters The head of the Filter chain.
 * @param canvas The target canvas buffer.
 * @param age The age of the dots (0.0 for new).
 * @param alpha The opacity/alpha factor.
 */
template<int W>
void plot_dots(const Dots& dots, Filter<W>& filters, Canvas& canvas, float age, float alpha) {
  for (auto& dot : dots) {
    auto p = vector_to_pixel<W>(dot.position);
    filters.plot(canvas, p.x, p.y, gamma_correct(dot.color), age, alpha);
  }
}


/**
 * @brief Type alias for a function that draws an object using a specific orientation and age factor.
 */
typedef std::function<void(const Quaternion&, float)> TweenFn;

/**
 * @brief Iterates over the Orientation's history and calls a draw function for each historical step.
 * @details This is the core mechanism for creating motion blur or trails.
 * @param orientation The Orientation object containing historical states.
 * @param draw_fn The drawing function, accepting the Orientation quaternion and a normalized age factor (t).
 */
void tween(const Orientation& orientation, TweenFn draw_fn) {
  size_t s = orientation.length();
  for (size_t i = 0; i < s; ++i) {
    draw_fn(orientation.get(i),
      static_cast<float>((s - 1 - i)) / s);
  }
}